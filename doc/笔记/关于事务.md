
## 并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的
任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

**脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改
还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。
因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，
依据“脏数据”所做的操作可能是不正确的。

**丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问
了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样
第一个事务内的修改结果就被丢失，因此称为丢失修改。	例如：事务1读取某表中的数据
A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务
1的修改被丢失。

**不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还
没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第
二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两
次读到的数据是不一样的情况，因此称为不可重复读。

**幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几
行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务
（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

## 事务隔离级别

SQL 标准定义了四个隔离级别：

**READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，
可能会导致脏读、幻读或不可重复读

**READ-COMMITTED(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，
但是幻读或不可重复读仍有可能发生

**REPEATABLE-READ（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被
本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

**SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次
逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

隔离级别	             脏读	不可重复读	幻影读
READ-UNCOMMITTED	  √	       √	      √
READ-COMMITTED        ×	       √	      √
REPEATABLE-READ       ×	       ×	      √
SERIALIZABLE	      ×	       ×          ×