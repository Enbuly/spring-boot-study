
## 乐观锁常见的两种实现方式
## 乐观锁一般会使用版本号机制或CAS算法实现。

### 版本号机制

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，
version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更
新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

举一个简单的例子:
假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。

1. 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。
2. 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。
3. 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），
提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
4. 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），
但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，
不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。

这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。

sql:
update user set status=#{status},salary=20000 where id=#{id} and #{status}>status;

### CAS

CAS算法 即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，
即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实
现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

需要读写的内存值 V
进行比较的值 A
拟写入的新值 B
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任
何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

for example:
public class SimpleLock{

    //Java中的原子操作（CAS）持有自旋锁的线程对象
    AtomicReference<Thread> owner = new AtomicReference<Thread>();
    private int count;

    public void lock(){
        Thread curThread = Thread.currentThread();
        //lock函数将owner设置为当前线程，并且预测原来的值为空
        //当有第二个线程调用lock操作时由于owner的值不为空，导致循环
        //一直被执行，直至第一个线程调用unclock函数将owner设置为null，第二个线程才能进入临界区
        while(!owner.compareAndSet(null, curThread)){
        }
    }

    //unlock将owner的值设置为null，并且预测值为当前线程
    public void unlock(){
        Thread cur = Thread.currentThread();
        owner.compareAndSet(cur, null);
    }

}

CAS与synchronized的使用情景
简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），
synchronized适用于写比较多的情况下（多写场景，冲突一般较多）

对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行
线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；
而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，
因此可以获得更高的性能。
对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而
浪费更多的CPU资源，效率低于synchronized。
补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，
很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主
要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁
以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底
层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续
竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以
获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。